<head></head>

<body>
  <script>
    function Person(name, age) {
      this.name = name;
      this.age = age;
      this.greet = function () {
        console.log(`${name}, aged ${age}: Hi!`);
      };
    }

    const person = new Person("Mat", 30);

    // Prototype (__proto__): fall-back object
    // Every object has a '__proto__' property acquired when created, with an object value
    // e.g. an object, when created, by default has __proto__ = Object (the Object prototype) and
    // has object methods like hasOwnProperty()
    // If a certain property can't be found in the object, will search for the properties inside the prototype,
    // then prototype's prototype until it reaches the end. If that property is not found, throws error.

    // JS is a *Prototype-base language*

    // 'prototype' vs '__proto__'
    // 'prototype' only exists in non-arrow functions. __proto__ is in every object
    // Constructor's 'prototype' is assigned to new instance's '__proto__'
    console.log(person.__proto__ === Person.prototype); // true! (for objects === is true only when both points to same reference)

    // A prototype of an object can be accessable to all new instances of that object
    // because the object inherits from the prototype.
    // Every new instance won't have a copy of the things defined in the prototype, as
    // opposed to what will happen when you define things in a constructor.

    Student.prototype.sayName = function (times) {
      // Using arrow functions above will affect the behaviour of 'this', doesn't work
      for (let i = 0; i < times; i++) {
        console.log(`${this.name} ${i}`);
      }
    }; // good to define a METHOD in a prototype so that it can be reused for all instances
    // without having a copy in all of them

    lauriaC.sayName(3); // will inherit from the prototype (even if the prototype is defined after it)
  </script>
</body>
