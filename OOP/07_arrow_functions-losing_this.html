<script>
  "use strict";
  /**
   * Arrow functions
   */
  // https://javascript.info/arrow-functions#arrow-functions-have-no-this
  // Arrow functions DO NOT BIND 'this' for us; it does not create any execution context
  //  - Think like it is "transparent"
  // That does not mean you can't use `this` inside an arrow function
  // When 'this' is called inside an arrow function, 'this' will be taken from the CLOSEST ENCLOSING CONTEXT that has a `this`.
  // e.g. if the function is enclosed by ANOTHER FUNCTION that has a `this` defined = A, then `this` === A
  // e.g. if the function is not enclosed by any contexts, `this` === the global object (the closest enclosing context)!
  // !!! bind, call & apply will have NO EFFECT on arrow functions
  let obj = {
    sayThis: () => {
      console.log(this);
    },
  };
  obj.sayThis(); // Window {}; `obj` is a plain object and is NOT a context!

  let user2 = {
    firstName: "Ilya",
    // We wrap the arrow function inside ANOTHER non-arrow function
    // sayHi has a `this` === user2
    sayHi() {
      let arrow = () => alert(this.firstName);
      arrow();
    },
  };
  user2.sayHi(); // `arrow` takes `this` from the enclosing context (sayHi) which has a `this`, so it will return user2.firstName === Ilya

  /**
   * Browser binding "this" on callbacks & losing "this"
   */
  // https://javascript.info/bind#losing-this
  // If we pass a function directly as a CALLBACK (hence not called YET), we will lose the original "this"
  let user = {
    firstName: "John",
    sayHi() {
      console.log(`Hello, ${this.firstName}!`);
    },
  };
  setTimeout(user.sayHi, 1000); // "Hello, undefined!" <-- we expected "Hello, John!" !!!
  // Reason: user.sayHi is NOT called by `user`. We passed the REFERENCE of the `sayHi` function to `setTimeout`
  // We actually delegated the call to some other contexts in the browser code that will bind `this` = `window` by default
  //  - https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#the_this_problem
  // The same will happen for event listeners, and it will set `this` = the event object
  // Solution 1 : user a wrapper
  setTimeout(() => {
    user.sayHi(); // now sayHi is called by `user`!
  }, 1000);
  // Solution 2. use bind()
  setTimeout(user.sayHi.bind(user), 1000);
  // Solution 3: use arrow functions instantiated as methods inside ES6 class fields
  //  - https://javascript.info/class#making-bound-methods-with-class-fields
  // *** Why? vvvvv
  // ES6 class fields are defined SEPARATELY for each object, and `this` is bound to the new object instantiated by the class (which is a FUNCTION)
  // !!! Downside: you have a copy of the arrow function in every instances of the class (instead of inherited in the prototype)
  //  - In general, it is discouraged to use arrow functions as methods
  //  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#arrow_functions_used_as_methods

  // Example:
  class Button {
    constructor(value) {
      this.value = value;
      // arrow function
      this.click = () => {
        console.log(this.value);
      };
      // non-arrow function
      this.click2 = function () {
        console.log(this.value + "2");
      };
    }
  }

  const button = new Button("hello");

  setTimeout(button.click, 1); // hello --> arrow functions is not affected by setTimeout's overidding 'this'
  setTimeout(button.click2, 1); // undefined2 --> non-arrow function is susceptible
</script>
