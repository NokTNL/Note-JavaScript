<script>
  "use strict";
  // `this` tells us FROM WHERE a function is being executed.
  // What is returned from `this` depends on in what EXECUTION CONTEXT (the "function") `this` was called.
  /**
   * Global context
   */
  // When 'this' is called in the GLOBAL context, it always refer to the global object ("window")
  this.b = "Something"; // Assigning a value to the "window" object
  console.log(this.b); // "Something", also identical to:
  console.log(b); // "Something"

  /**
   * Function context
   */
  // Inside a FUNCTION, the function will bind 'this' to the OBJECT that called the function
  // Sometimes it is called the "before-dot" object
  // Remember a JS object can have propeties that bear functions as values (a "method"):
  const movie = {
    info: {
      title: "Star Wars",
      director: "George Lucas",
    },
    id: 1,
    // This is a method of `movie`
    getFormattedTitle: function () {
      return this.info.title.toUpperCase();
    },
  };
  console.log(movie.getFormattedTitle()); // When `getFormattedTitle` is executing, `this` inside `getFormattedTitle` === `movie`

  // That means if I extract the method out from one object and assign it to another object, ...
  // ... it still refers to the SAME function in the memory (as functions are passed by reference), ...
  // but the new method will have a new `this`!
  const newMovie = {
    info: {
      title: "Hobbits",
    },
    getFormattedTitle: movie.getFormattedTitle,
  };
  console.log(newMovie.getFormattedTitle()); // `this` === `newMovie` inside this method!

  // In STRICT MODE, functions that are NOT called from an object will have `this` remains === undefined
  // In non-strict mode, `this` === global object in this case
  let { getFormattedTitle } = movie;
  // getFormattedTitle();  // !! Throws error as `getFormattedTitle` is called as a `let` value (not called from any objects), so `this` === undefined inside `getFormattedTitle`

  /**
   * Binding "this" manually
   */
  // We can force what object "this" refers to in a function context even if it was not called from that object
  // bind() will return a NEW function that has `this` bound to the specified object
  getFormattedTitle = getFormattedTitle.bind(movie); // now `this` inside the function refers to the original `movie` object
  console.log(getFormattedTitle()); // "STAR WARS"
  // call() will bind "this" for the function and CALL the function straight away: (apply() is similar)
  console.log(getFormattedTitle.call(movie)); // "STAR WARS"
</script>
