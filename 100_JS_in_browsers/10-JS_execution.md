- Overall explanation for V8: https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775

- The browser first parse the JS code into an ABSTRACT SYNTAX TREE with a **PARSER**
  - https://jotadeveloper.medium.com/abstract-syntax-trees-on-javascript-534e33361fc7#:~:text=Abstract%20syntax%20trees%20are%20data,result%20of%20a%20syntax%20analysis.
  - The job of a parser is to extract the STRUCTURE of your code into a tree like this:

```
    {
  "type": "Program",
  "start": 0,
  "end": 6,
  "range": [
    0,
    6
  ],
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 6,
      "range": [
        0,
        6
      ],
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 4,
          "end": 5,
          "range": [
            4,
            5
          ],
          "id": {
            "type": "Identifier",
            "start": 4,
            "end": 5,
            "range": [
              4,
              5
            ],
            "name": "a"
          },
          "init": null
        }
      ],
      "kind": "var"
    }
  ],
  "sourceType": "module"
}
```

- An **INTERPRETER** (e.g. Ignition in V8) then generate BYTECODES from this tree. What it does is equivalent to reading the JS code line-by-line.
  - Example of generated bytecodes:

```
StackCheck
LdaSmi [1]
Star r0
LdaNamedProperty a0, [0], [4]
Add r0, [6]
Return
```

- bytecodes are the smallest units of opearitions you can do in JS; they are one layer of abstract higher and are NOT the code that will finally be run on your hardware (the _machine code_)
- You can run this bytecode directly (by a "baseline compiler" that turns it into machine code) but it is often unoptimised

- To optimise performance, an **Optimisation Compiler** (e.g. Turbofan & Crankshaft in V8) re-compiles the bytecode again at runtime into optimised machine code

  - The bytecode is compiled after each line of interpretation instead of waiting for the whole file to be compiled. This is called **Just-in-time compiling (JiT)**

- The interpreter also have access to the **Browser API objects** (e.g. fetch, the `document` object for DOM manipulation, which we call in our JS scipts) so they will be included when the code is being interpreted into bytecode as well
